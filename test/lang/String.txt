namespace lang;

public final class String {
    public final string value;

    public this(string value) {
        this.value = value;
    }

    public string toString() {
        return value;
    }

    public int hash() {
        return value.hash();
    }

    public bool equals(let Object other) {
        let obj = (String) other;
        return obj != null && obj.value == value;
    }
}

public static struct string : String {

    public int Length {
        get {
            native (source) {
                return data == nullptr ? 0 : data->length;
            }
        }
    }

    public int CodePoints {
        get {
            native (source) {
                return data == nullptr ? 0 : data->cp;
            }
        }
    }

    public byte this[int i] {
        get {
            native (return) {
                return data == nullptr ? 0 : data->chars[ ARRAY_ACESS(v_i, data->length) ];
            }
        }
    }

    native (header) {
        lang::string * data;

        lang_string(const lang_string& str);
        lang_string(lang::string* data);
        lang_string(const char* str);
        ~lang_string();
        lang_string& operator=(const lang_string &str);
    }

    native (source) {
        lang_string::lang_string(const lang_string& str) {
            this->data = str.data;
            lang::text::asg(data);
        }
        lang_string::lang_string(lang::string* data) {
            this->data = data;
            lang::text::asg(data);
        }
        lang_string::lang_string(const char* str) {
            this->data = lang::text::cstr(str);
        }
        lang_string::~lang_string() {
            lang::text::dsg(data);
        }
        lang_string& lang_string::operator=() {
            if (this->data != other->data) {
                lang::text::dsg(data);
                this->data = other->data;
                lang::text::asg(data);
            }
        }
    }

    public this() {
        native (source) {
            this->data = nullptr;
        }
    }

    public this(string copy) {
        native (source) {
            this->data = v_copy.data;
            lang::text::asg(data);
        }
    }

    public this(let byte[] chars) {
        this(chars, 0, chars.Length);
    }

    public this(let byte[] chars, int start, int length) {
        this(chars, 0, chars.Length, 8);
    }

    public this(let byte[] chars, int start, int length, int charSet) {
        if (start < 0) start = 0;
        if (start > chars.Length) start = chars.Length;
        if (length > chars.Length) length = chars.Length;

        native (source) {
            this->data = lang::text::str(&v_chars->data[v_start], v_length, v_charSet);
        }
    }

    public this(let short[] chars) {
        this(chars, 0, chars.Length);
    }

    public this(let short[] chars, int start, int length) {
        if (start < 0) start = 0;
        if (start > chars.Length) start = chars.Length;
        if (length > chars.Length) length = chars.Length;

        native (source) {
            this->data = lang::text::str(&v_chars->data[v_start], v_length, 16);
        }
    }

    public this(let int[] chars) {
        this(chars, 0, chars.Length);
    }

    public this(let int[] chars, int start, int length) {
        if (start < 0) start = 0;
        if (start > chars.Length) start = chars.Length;
        if (length > chars.Length) length = chars.Length;

        native (source) {
            this->data = lang::text::str(&v_chars->data[v_start], v_length, 32);
        }
    }

    public bool equalsIgnoreCase(string other) {
        native (return) {
            if (this->data == v_other->data) return true;
            if (this->data == nullptr || v_other->data == nullptr) return false;
        }

        if (other.CodePoints != CodePoints) return false;

        var it = iterateUTF32();
        var itOther = other.iterateUTF32();
        var l = Locale.GlobalLocale;

        while (it.hasNext()) {
            if (l.toUpperCase(it.next()) != l.toUpperCase(itOther.next())) {
                return false;
            }
        }

        return true;
    }

    public int hash() {
        native (return) {
            return lang::text::hash(data);
        }
    }

    public string toUpperCase() {
        return toUpperCase(Locale.GlobalLocale);
    }

    public string toUpperCase(Locale locale) {
        final Text text = new Text(CodePoints);
        for (int i : this) {
            text.addCodePoint(locale.toUpperCase(i));
        }
        return text.toString();
    }

    public string toLowerCase() {
        return toLowerCase(Locale.GlobalLocale);
    }

    public string toLowerCase(Locale locale) {
        final Text text = new Text(CodePoints);
        for (int i : this) {
            text.addCodePoint(locale.toLowerCase(i));
        }
        return text.toString();
    }

    public Iterator<int> iterateUTF32() {
        return new StringUTF32Iterator(this);
    }

    public Iterator<short> iterateUTF16() {
        return new StringUTF16Iterator(this);
    }

    public Iterator<byte> iterateUTF8() {
        return new StringUTF8Iterator(this);
    }

    bool operator ==(string value, string other) {
        native (return) {
            if (this->data == v_other->data) return true;
            if (this->data == nullptr || v_other->data == nullptr) return false;
            if (this->data.length != v_other.data.length) return false;

            for (int i = 0, len = this->data.length; i < len; i++) {
                if (this->data[i] != v_other->data[i]) {
                    return false;
                }
            }
            return true;
        }
    }

    bool operator >(string value, string other) {
    }

    bool operator <(string value, string other) {
    }

    bool operator >=(string value, string other) {
    }

    bool operator <=(string value, string other) {
    }

    string operator +(string value, string other) {
    }
}

final class StringUTF8Iterator : Iterator<byte> {

    private string content;
    private int index;

    public this(string content) {
        this.content = content;
    }

    public byte next() {
        if (index < content.Length) {
            native (source) {
                return content.data->chars[f_index ++];
            }
        } else {
            return 0;
        }
    }

    public bool hasNext() {
        return index < content.Length;
    }

    public bool remove() {
        return false;
    }
}

final class StringUTF16Iterator : Iterator<short> {

    private string content;
    private int index;
    private short nextPar;

    public this(string content) {
        this.content = content;
    }

    public short next() {
        return 0;
    }

    public bool hasNext() {
        return false;
    }

    public bool remove() {
        return false;
    }
}

final class StringUTF32Iterator : Iterator<int> {

    private string content;
    private int index;

    public this(string content) {
        this.content = content;
    }

    public int next() {
        return 0;
    }

    public bool hasNext() {
        return false;
    }

    public bool remove() {
        return false;
    }
}